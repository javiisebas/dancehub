import { BaseTranslatableRepository{{#if relations}}, defineRelations, relation{{/if}} } from '@api/modules/core/database/base';
import { Injectable } from '@nestjs/common';
import { FilterOperator } from '@repo/shared';
import { PgColumn } from 'drizzle-orm/pg-core';
import { {{pascalCase name}}Translation } from '../../domain/entities/{{kebabCase name}}-translation.entity';
import { {{pascalCase name}} } from '../../domain/entities/{{kebabCase name}}.entity';
import { I{{pascalCase name}}Repository } from '../../domain/repositories/i-{{kebabCase name}}.repository';
import { {{camelCase (pluralize name)}}, {{camelCase name}}Translations } from '../schemas';
{{#if fields}}
{{#each fields}}
{{#if isEnum}}
import { {{enumName}} } from '@repo/shared';
{{/if}}
{{/each}}
{{/if}}
{{#if relations}}
{{#each relations}}
import { {{entity}} } from '../../../{{kebabCase (singularize table)}}/domain/entities/{{kebabCase (singularize table)}}.entity';
import { {{camelCase table}} } from '../../../{{kebabCase (singularize table)}}/infrastructure/schemas/{{kebabCase (singularize table)}}.schema';
{{/each}}
{{/if}}

{{#if relations}}
const {{camelCase name}}Relations = defineRelations({
{{#each relations}}
    {{name}}: relation.{{#if (eq type 'one')}}manyToOne{{else}}oneToMany{{/if}}({
        entity: {{entity}},
        table: {{camelCase table}},
        foreignKey: '{{#if (eq type 'one')}}{{fields.[0]}}{{else}}{{@root.name}}Id{{/if}}',
    }),
{{/each}}
});

{{/if}}
@Injectable()
export class {{pascalCase name}}RepositoryImpl
    extends BaseTranslatableRepository<
        {{pascalCase name}},
        {{pascalCase name}}Translation,
        typeof {{camelCase (pluralize name)}},
        typeof {{camelCase name}}Translations{{#if relations}},
        typeof {{camelCase name}}Relations{{/if}}
    >
    implements I{{pascalCase name}}Repository
{
    protected readonly table = {{camelCase (pluralize name)}};
    protected readonly translationTable = {{camelCase name}}Translations;
    protected readonly entityName = '{{pascalCase name}}';
    {{#if relations}}
    protected readonly relations = {{camelCase name}}Relations;
    {{/if}}

    protected toDomain(schema: typeof {{camelCase (pluralize name)}}.$inferSelect): {{pascalCase name}} {
        return new {{pascalCase name}}(
            schema.id,
            schema.slug,
{{#if fields}}
{{#each fields}}
            {{#if (eq drizzleType 'numeric')}}{{#if required}}parseFloat(schema.{{camelCase name}}){{else}}schema.{{camelCase name}} ? parseFloat(schema.{{camelCase name}}) : null{{/if}}{{else}}schema.{{camelCase name}}{{#if isEnum}} as {{tsType}}{{/if}}{{/if}},
{{/each}}
{{/if}}
{{#if foreignKeys}}
{{#each foreignKeys}}
            schema.{{camelCase name}},
{{/each}}
{{/if}}
            schema.createdAt,
            schema.updatedAt,
        );
    }

    protected toSchema(entity: {{pascalCase name}}): any {
        return {
            slug: entity.slug,
{{#if fields}}
{{#each fields}}
{{#if required}}
            {{camelCase name}}: {{#if (eq drizzleType 'numeric')}}entity.{{camelCase name}}.toString(){{else}}entity.{{camelCase name}}{{/if}},
{{else}}
            ...(entity.{{camelCase name}} !== undefined && entity.{{camelCase name}} !== null && { {{camelCase name}}: {{#if (eq drizzleType 'numeric')}}entity.{{camelCase name}}.toString(){{else}}entity.{{camelCase name}}{{/if}} }),
{{/if}}
{{/each}}
{{/if}}
{{#if foreignKeys}}
{{#each foreignKeys}}
{{#if required}}
            {{camelCase name}}: entity.{{camelCase name}},
{{else}}
            ...(entity.{{camelCase name}} !== undefined && entity.{{camelCase name}} !== null && { {{camelCase name}}: entity.{{camelCase name}} }),
{{/if}}
{{/each}}
{{/if}}
        };
    }

    protected translationToDomain(
        schema: typeof {{camelCase name}}Translations.$inferSelect,
    ): {{pascalCase name}}Translation {
        return new {{pascalCase name}}Translation(
            schema.id,
            schema.locale,
            schema.name,
            schema.description,
            schema.createdAt,
            schema.updatedAt,
        );
    }

    protected translationToSchema(
        translation: {{pascalCase name}}Translation,
        entityId: string,
    ): Partial<typeof {{camelCase name}}Translations.$inferInsert> {
        return {
            {{camelCase name}}Id: entityId,
            locale: translation.locale,
            name: translation.name,
            description: translation.description || undefined,
        } as Partial<typeof {{camelCase name}}Translations.$inferInsert>;
    }

    protected getTranslationEntityIdColumn(): PgColumn {
        return {{camelCase name}}Translations.{{camelCase name}}Id;
    }

    async findBySlug(slug: string): Promise<{{pascalCase name}} | null> {
        return this.findOne({
            filter: {
                field: 'slug',
                operator: FilterOperator.EQ,
                value: slug,
            },
        });
    }

    async slugExists(slug: string): Promise<boolean> {
        return this.exists({
            field: 'slug',
            operator: FilterOperator.EQ,
            value: slug,
        });
    }
}
