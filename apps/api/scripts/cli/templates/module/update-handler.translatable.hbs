import { UpdateCommand } from '@api/common/abstract/application/commands.abstract';
import { ConflictException, Inject, Injectable } from '@nestjs/common';
import { Update{{pascalCase name}}Request } from '@repo/shared';
import { randomUUID } from 'crypto';
import { {{pascalCase name}}Translation } from '../../domain/entities/{{kebabCase name}}-translation.entity';
import {
    {{constantCase name}}_REPOSITORY,
    I{{pascalCase name}}Repository,
} from '../../domain/repositories/i-{{kebabCase name}}.repository';

export class Update{{pascalCase name}}Command extends UpdateCommand<Update{{pascalCase name}}Request> {}

@Injectable()
export class Update{{pascalCase name}}Handler {
    constructor(
        @Inject({{constantCase name}}_REPOSITORY) private readonly repository: I{{pascalCase name}}Repository,
    ) {}

    async execute({ id, data }: Update{{pascalCase name}}Command) {
        const {{camelCase name}} = await this.repository.findById(id);

        if (data.slug && data.slug !== {{camelCase name}}.slug) {
            const slugExists = await this.repository.slugExists(data.slug);
            if (slugExists) {
                throw new ConflictException('Slug already exists');
            }
            {{camelCase name}}.updateSlug(data.slug);
        }

{{#if fields}}
{{#each fields}}
        if (data.{{camelCase name}} !== undefined) {{camelCase ../name}}.update{{pascalCase name}}(data.{{camelCase name}});
{{/each}}
{{/if}}
{{#if foreignKeys}}
{{#each foreignKeys}}
        if (data.{{camelCase name}} !== undefined) {{camelCase ../name}}.{{camelCase name}} = data.{{camelCase name}};
{{/each}}
{{/if}}

        const translations = data.translations?.map((t) =>
            {{pascalCase name}}Translation.create(randomUUID(), t.locale, t.name, t.description),
        );

        return this.repository.updateWithTranslations({{camelCase name}}, translations);
    }
}
